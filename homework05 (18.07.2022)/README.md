# Задание №1 - Свой список

Нужно реализовать класс LinkedList, в котором можно будет хранить элементы класса Node. У класса должны быть методы для добавления в конец и произвольную позицию, удаления и поиска элемента. Классы должны быть описаны в разных файлах. 
У класса должен быть реализован метод to_s для лаконичного отображения.

**Реализация**

Данное задание реализовано с помощью двух классов: LinkedList и Node. Узел способен принимать "указатель" на следующий элемент и данные. Также в узле прописан метод для корректного отображения.
В импровизированном списке реализованы все прочие методы, согласно заданию. Дополнительно реализованы методы find_after и find_before, для поиска элементов перед и за данным элементом.
Данные методы были взяты из данного источника: https://www.rubyguides.com/2017/08/ruby-linked-list/

# Задание №2 - Пагинация массива

Нужно реализовать класс PaginationHelper, который позволит пагинировать массив.
Класс получает в конструктор сам массив и число элементов для дробления массива.

Реализован класс PaginationHelper со всеми необходимыми методами согласно условию задачи. 
Рассмотрим реализацию методов.
1. **page_count**. Для подсчета страниц мы разделим длину массива на количество элементов на одной страницы, округлив значение в большую сторону
2. **page_item_count**. Проверяем, если номер страницы меньше самого количества страниц и больше или равен нулю, то смотрим далее: если входной номер страницы равен количеству страниц минус один (последняя страница), то выводим количество элементов на данной странице по формуле: (длинна_массива - (длинна_массива/количество_элементов_на_странице) * количество_элементов_на_странице); иначе выводим количество элементов на странице. Если первоначальное условие не выполнено, то выводим -1.
3. **page_index**. Проверяем индекс на положительность. Если да, то выводим значение по формуле: индекс /количество_элементов_на_странице. Иначе выводим -1
