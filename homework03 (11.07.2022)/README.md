**Задание №1 - Пять примеров**

Для выполнения реализовано три функции. Рассмотрим их.

* Функция 1 - hash_methods()

Пять методов для хэша: has_key?, inspect, shift, size, value?

* Функция 2 - array_methods()

Пять методов для массива: создание массива через new, push, pop, delete_at, reverse!

* Функция 3 - range_methods()

Пять методов для ранга: to_a, step(), include?, cover?, max

**Задание №2 - Простановка рангов для массива чисел**

В файле закомментированы тестовые варианты. Функция inputting_ranks() работает исправно согласно примерам. 

Реализация: определяем переменные пустого массива ranks, который заполняем нулями и который по длине равен исходному массиву. Также определяем две переменные: num_ranks (номер ранга) и count_ranks (количество рангов - для повторяющихся значений). В цикле смотрим массив, в котором ищем максимальный элемент. Когда нашли - записали в массив рангов по такому же индексу значение ранга, а в массиве чисел данному максимальному числу присуждаем значение -99999 как самое минимальное. Затем смотрим, равен ли слудующий максимальный элемент текущему максимуму: если да, то номер ранга сохраняем, иначе - равняем его количеству рангов.

**Задание №3 - Перевод строки в хэш**

Данная задача решается в две строки в функции str_to_hash(). В функции определяем переменную pairs = buf_string.split(/[,=]/).map(&:strip).each_slice(2).map { |k,v| [k.strip.to_sym, v.strip] }. Сначала мы делим строку по разделителям (запятая и равно), затем убираем пробелы, далее "нарезаем" строку по два элемента (ключ и значение), далее переводим их в хэш в блоке. Затем результат pairs заносим как определяющий элемент хэша на следующей строке и выводим его с помощью функции testing_hash().
